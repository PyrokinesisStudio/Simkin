/*
  Copyright 1996-2001
  Simon Whiteside

  $Id: skInterpreter.cpp,v 1.24 2001/03/05 16:46:28 sdw Exp $
*/

#include "skInterpreter.h"
#include "skInterpreterp.h"
#include "skParseNode.h"
#include <ctype.h>
#include "skLang_tab.h"
#include "skString.h"
#include <stdio.h>
#include "skRValueArray.h"
#include <stdarg.h>
#include "skStringList.h"
#include "skParseException.h"
#include "skRuntimeException.h"
#include "skTracer.h"

LITERAL(true);
LITERAL(false);
LITERAL(null);
LITERAL(self);
LITERAL(tracing);
LITERAL(Interpreter);
LITERAL(DebugBreak);

int yylex ( void );
void yyerror(char * msg);

struct KeyWord{
  skString * m_Text;
  int			m_Token;
};
KeyWord keywords[]={
  {new skString("while"),L_WHILE},
  {new skString("if"),L_IF},
  {new skString("else"),L_ELSE},
  {new skString("or"),L_OR},
  {new skString("and"),L_AND},
  {new skString("not"),L_NOT},
  {new skString("return"),L_RETURN},
  {new skString("lt"),L_LT},
  {new skString("gt"),L_GT},
  {new skString("switch"),L_SWITCH},
  {new skString("case"),L_CASE},
  {new skString("default"),L_DEFAULT}
};
const int NUMKEYS=sizeof(keywords)/sizeof(KeyWord);
const int MAX_ARGS=256;

skInterpreter * P_Interpreter::g_GlobalInterpreter;	//	used by client
skInterpreter * P_Interpreter::g_Interpreter;
skString P_Interpreter::g_Location;
skString g_BlankString;
skNull skInterpreter::g_Null;

skMethodDefNode * g_TopNode; // this value is set by yyparse()
skParseNodeList g_TempNodes; // this list is built up by the parser as it goes along
skCompileErrorList* g_ErrList; // yyerror() will add to the list if there are errors
extern int yyparse(); // the parser generated by bison

//---------------------------------------------------
skInterpreter::skInterpreter()
  //---------------------------------------------------
{
  P_Interpreter::g_Interpreter=this;
  pimp=new P_Interpreter;
  addGlobalVariable(s_Interpreter,this);
}
//---------------------------------------------------
P_Interpreter::P_Interpreter()
  //---------------------------------------------------
  : m_PutBack(0),m_Pos(0),m_Tracing(false),m_StackDepth(0)
{
}
//---------------------------------------------------
P_Interpreter::~P_Interpreter()
  //---------------------------------------------------
{
}
//---------------------------------------------------
skInterpreter::~skInterpreter()
  //---------------------------------------------------
{
  delete pimp;
}
//---------------------------------------------------
skInterpreter * skInterpreter::getInterpreter()
  //---------------------------------------------------
{
  return P_Interpreter::g_GlobalInterpreter;
}
//---------------------------------------------------
void skInterpreter::setInterpreter(skInterpreter * i)
  //---------------------------------------------------
{
  P_Interpreter::g_GlobalInterpreter=i;
}
//---------------------------------------------------
bool P_Interpreter::executeStat(skExecutable * obj,skRValueTable& var,skStatNode * pstat,skRValue& r)
  //---------------------------------------------------
{
  bool stop=false;
  switch(pstat->getType()){
  case s_If:
    stop=executeIfStat(obj,var,(skIfNode*)pstat,r);break;
  case s_While:
    stop=executeWhileStat(obj,var,(skWhileNode*)pstat,r);break;
  case s_Return:
    stop=executeReturnStat(obj,var,(skReturnNode*)pstat,r);break;
  case s_Assign:
    executeAssignStat(obj,var,(skAssignNode*)pstat);break;
  case s_Method:
    r=evalMethod(obj,var,((skMethodStatNode*)pstat)->m_Ids);break;
  case s_Switch:
    stop=executeSwitchStat(obj,var,(skSwitchNode*)pstat,r);break;
  }
  return stop;
}
//---------------------------------------------------
bool P_Interpreter::executeStats(skExecutable * obj,skRValueTable& var,skStatListNode * n,skRValue& r)
  //---------------------------------------------------
{
  bool bRet=false;
  if (n){
    skStatListIterator iter(n->m_Stats);
    skStatNode * node=0;
    while ((node=iter())!=0){
      bRet=executeStat(obj,var,node,r);
      // break out if stop has been passed back
      if (bRet)
	break;
    }
  }
  return bRet;
}
//---------------------------------------------------
void P_Interpreter::addLocalVariable(skRValueTable& var,const skString& name,skRValue value)
  //---------------------------------------------------
{
  skRValue * pvalue=var.value(&name);
  if (pvalue)
    *pvalue=value;
  else
    var.insertKeyAndValue(new skString(name),new skRValue(value));
}
//------------------------------------------
bool skInterpreter::findGlobalVariable(const skString& s,skRValue& r)
  //------------------------------------------
{
  bool bRet=false;
  skRValue * pvalue=pimp->m_GlobalVars.value(&s);
  if (pvalue){
    r=*pvalue;
    bRet=true;
  }
  return bRet;
}
//------------------------------------------
void skInterpreter::addGlobalVariable(const skString& s,skRValue r)
  //------------------------------------------
{
  skRValue * pvalue=pimp->m_GlobalVars.value(&s);
  if (pvalue)
    *pvalue=r;
  else
    pimp->m_GlobalVars.insertKeyAndValue(new skString(s),new skRValue(r));
}
//------------------------------------------
void skInterpreter::removeGlobalVariable(const skString& s)
  //------------------------------------------
{
  pimp->m_GlobalVars.del(&s);
}
//---------------------------------------------------
void P_Interpreter::followIdList(skExecutable * obj,skRValueTable& var,skIdListNode * idList,skRValue& object)
  //---------------------------------------------------
{
  // skip down the id.id.id list, resolving each as we go along, we exclude the final id in the list
  skIdNode * idNode=idList->m_Ids[0];
  skString name=idNode->m_Id;
  //  skTracer::trace("followIdList: %s - %d ids\n",(const char *)name,idList->m_Ids.entries());
  if (idNode->m_Exprs==0)
    object=findValue(obj,var,name,g_BlankString);
  else
    makeMethodCall(obj,skRValue(obj),var,name,idNode->m_Exprs,object);
  for (unsigned int i=1;i<idList->m_Ids.entries()-1;i++){
    idNode=idList->m_Ids[i];
    name=idNode->m_Id;
    //    skTracer::trace("followIdList: %d: %s\n",i,(const char *)name);
    skRValue result;
    if (idNode->m_Exprs==0)
      extractValue(obj,object,name,g_BlankString,result);
    else
      makeMethodCall(obj,object,var,name,idNode->m_Exprs,result);
    object=result;
  }
}
//---------------------------------------------------
skRValue  P_Interpreter::evalMethod(skExecutable * obj,skRValueTable& var,skIdListNode * ids)
  //---------------------------------------------------
{
  skRValue ret;
  skIdNode * idNode=ids->getLastId();
  skString method_name=idNode->m_Id;
  if (ids->numIds()==1){
    makeMethodCall(obj,skRValue(obj),var,method_name,idNode->m_Exprs,ret);
  }else{
    // follow the chain of Id's and then call the method
    skRValue robject;
    followIdList(obj,var,ids,robject);
    makeMethodCall(obj,robject,var,method_name,idNode->m_Exprs,ret);
  }
  return ret;
}
//---------------------------------------------------
void  P_Interpreter::makeMethodCall(skExecutable * obj,skRValue& robject,skRValueTable& var,const skString& method_name,skExprListNode * exprs,skRValue& ret)
  //---------------------------------------------------
{
  skString checked_method_name=checkIndirectId(obj,var,method_name);
  if (robject.type()==skRValue::T_Object){
    skRValueArray args;
    skExprListIterator iter(exprs->m_Exprs);
    skExprNode * expr=0;
    while ((expr=iter())!=0)
      args.append(evaluate(obj,var,expr));
    if (m_Tracing)
      skTracer::trace("skInterpreter: %s()\n",(const char *)checked_method_name);
    // call to this object
    bool bRet=robject.obj()->method(checked_method_name,args,ret);	
    if (bRet==false)
      runtimeError("Method %s not found\n",(const char *)checked_method_name);
  }else{
    runtimeError("Cannot call Method %s on a non-object\n",(const char *)checked_method_name);
  }
}
//---------------------------------------------------
bool P_Interpreter::executeReturnStat(skExecutable * obj,skRValueTable& var,skReturnNode * n,skRValue& r)
  //---------------------------------------------------
{
  r=evaluate(obj,var,n->m_Expr);
  return true;
}
//---------------------------------------------------
bool P_Interpreter::executeWhileStat(skExecutable * obj,skRValueTable& var,skWhileNode * n,skRValue& r)
  //---------------------------------------------------
{
  bool bRet=false;
  while(bRet==false){
    skRValue rExpr=evaluate(obj,var,n->m_Expr);
    if (rExpr.boolValue()){
      if (n->m_Stats)
	bRet=executeStats(obj,var,n->m_Stats,r);
    }else
      break;
  }
  return bRet;
}
//---------------------------------------------------
bool P_Interpreter::executeIfStat(skExecutable * obj,skRValueTable& var,skIfNode * n,skRValue& r)
  //---------------------------------------------------
{
  bool bRet=false;
  skRValue rExpr=evaluate(obj,var,n->m_Expr);
  if (rExpr.boolValue()){
    if (n->m_Stats)
      bRet=executeStats(obj,var,n->m_Stats,r);
  }else
    if (n->m_Else)		
      bRet=executeStats(obj,var,n->m_Else,r);
  return bRet;
}
//---------------------------------------------------
bool P_Interpreter::executeSwitchStat(skExecutable * obj,skRValueTable& var,skSwitchNode * n,skRValue& r)
  //---------------------------------------------------
{
  bool bRet=false;
  skRValue expr=evaluate(obj,var,n->m_Expr);
  skCaseNode * caseFound=0;
  skCaseListIterator iter(n->m_Cases->m_Cases);
  skCaseNode * caseNode=0;
  while ((caseNode=iter())!=0){
    skRValue testExpr=evaluate(obj,var,caseNode->m_Expr);
    if (testExpr==expr){
      caseFound=caseNode;
      break;
    }
  }
  if (caseFound!=0)
    bRet=executeStats(obj,var,caseFound->m_Stats,r);
  else if (n->m_Default!=0)
    bRet=executeStats(obj,var,n->m_Default,r);
  return bRet;
}
//---------------------------------------------------
skRValue P_Interpreter::findValue(skExecutable * obj,skRValueTable& var,const skString& name,const skString& attrib)
  //---------------------------------------------------
{              
  skRValue r;
  skString valueName=checkIndirectId(obj,var,name);
  if (valueName.length()){
    // first check some built-ins: true, false and self
    if (valueName==s_true)
      r=skRValue(true);
    else if (valueName==s_false)
      r=skRValue(false);
    else if (valueName==s_null)
      r=skRValue(&skInterpreter::g_Null);
    else if (valueName==s_self){
      if (attrib.length())
	extractValue(obj,skRValue(obj),g_BlankString,attrib,r);
      else
	r=obj;
    }else{
      // otherwise look up the scope hierarchy
      skRValue * pvalue=0;
      // first in the local variables
      pvalue=var.value(&valueName);
      if (pvalue){
	r=*pvalue;
	if (attrib.length()){
	    skRValue result;
	    extractValue(obj,r,g_BlankString,attrib,result);
	    r=result;
	}
      }else{
	// then in the instance fields
	if (obj==0 || extractValue(obj,skRValue(obj),valueName,attrib,r)==false){
	  // and finally in the global variables
	  pvalue=m_GlobalVars.value(&valueName);
	  if (pvalue){
	    r=*pvalue;
	    if (attrib.length()){
		skRValue result;
		extractValue(obj,r,g_BlankString,attrib,result);
		r=result;
	    }
	  }else
	    runtimeError("Field %s not found\n",(const char *)valueName);
	}	
      }	
    }
  }
  return r;
}
//---------------------------------------------------
bool P_Interpreter:: extractValue(skExecutable * obj,skRValue& robject,const skString& name,const skString& attrib,skRValue& ret) 
  //---------------------------------------------------
{
  bool found=false;
  if (robject.type()==skRValue::T_Object){
    //    skTracer::trace("Extracting %s:%s\n",(const char *)name,(const char *)attrib);
    found=robject.obj()->getValue(name,attrib,ret);
  }else
    runtimeError("Cannot get field %s from a non-object\n",(const char *)name);
  return found;
}
//---------------------------------------------------
void P_Interpreter::executeAssignStat(skExecutable * obj,skRValueTable& var,skAssignNode * n)
  //---------------------------------------------------
{
  skRValue value=evaluate(obj,var,n->m_Expr);
  skIdNode * idNode=n->m_Ids->getLastId();
  skString field_name=idNode->m_Id;
  if (n->m_Ids->numIds()==1){
    // special case where there is a single id
    bool inserted=false;
    if (obj!=0){
      if (field_name==s_self)
	inserted=insertValue(obj,skRValue(obj),g_BlankString,n->m_Ids->m_Attribute,value);
      else
	inserted=insertValue(obj,skRValue(obj),field_name,n->m_Ids->m_Attribute,value);
    }
    if (inserted==false)
      // if the object doesn't want this variable, we add it as a local variable
      addLocalVariable(var,field_name,value);
  }else{
    // otherwise follow the id's to the penultimate one
    skRValue robject;
    followIdList(obj,var,n->m_Ids,robject);
    insertValue(obj,robject,field_name,n->m_Ids->m_Attribute,value);
  }
}
//---------------------------------------------------
bool P_Interpreter::insertValue(skExecutable * obj,skRValue& robject,const skString& name,const skString& attr,const skRValue& value)
  //---------------------------------------------------
{
  bool found=false;
  if (robject.type()==skRValue::T_Object){
    found=robject.obj()->setValue(name,attr,value);
  }else
    runtimeError("Cannot set field %s on a non-object\n",(const char *)name);
  return found;
}
//---------------------------------------------------
void P_Interpreter::cleanupTempNodes()
  //---------------------------------------------------
{
  // delete the list of nodes accumulated during the parse - in the event of an error
  skParseNodeListIterator iter(g_TempNodes);
  skParseNode * node=0;
  while ((node=iter())!=0)
    node->clear();
  g_TempNodes.clearAndDestroy();
}
//---------------------------------------------------
void  skInterpreter::executeParseTree(const skString& location,skExecutable * obj,skMethodDefNode * pExecuteNode,skRValueArray& args,skRValue& r)
  //---------------------------------------------------
{      
  skString old_location=pimp->m_Location;
  pimp->m_Location=location;
  if (pExecuteNode){
    skRValueTable * pvars;
    if (pimp->m_StackDepth<MAX_LOCAL_VARS_CACHE)
      pvars=&pimp->m_LocalVars[pimp->m_StackDepth];
    else	
      pvars=new skRValueTable;
    // fix up parameters
    if (pExecuteNode->m_Params){
      for (unsigned int i=0;i<pExecuteNode->m_Params->m_Ids.entries();i++)
	if (i<args.entries())
	  pimp->addLocalVariable(*pvars,pExecuteNode->m_Params->m_Ids[i]->m_Id,args[i]);
    }
    pimp->m_StackDepth++;
    pimp->executeStats(obj,*pvars,pExecuteNode->m_Stats,r);
    pimp->m_StackDepth--;
    if (pimp->m_StackDepth>=MAX_LOCAL_VARS_CACHE)
      delete pvars;
    else
      pvars->clearAndDestroy();
  }
  pimp->m_Location=old_location;
}
//---------------------------------------------------
skMethodDefNode * skInterpreter::parseString(const skString& location,const skString& code)
  //---------------------------------------------------
{                                     
  skMethodDefNode * methNode=g_TopNode;
  pimp->m_Pos=0;    
  pimp->m_LineNum=0;
  pimp->m_InputBuffer=code;
  pimp->m_PutBack=0;
  skCompileErrorList errList;
  pimp->g_Location=location;
  g_ErrList=&errList;
  yyparse();
  if (g_TopNode){
    methNode=g_TopNode;
    g_TempNodes.clear();
  }else{
    pimp->cleanupTempNodes();
    throw skParseException(errList);
  }
  g_TopNode=0;
  g_ErrList=0;
  return methNode;
}
//---------------------------------------------------
skMethodDefNode * skInterpreter::parseExternalParams(const skString& location,skStringList& paramNames,const skString& code)
  //---------------------------------------------------
{                                     
  skMethodDefNode * methNode=parseString(location,code);
  // fix up the parameters
  if (methNode){
    if (methNode->m_Params==0)
      methNode->m_Params=new skIdListNode();
    else
      methNode->m_Params->m_Ids.clear();
    for (unsigned int i=0;i<paramNames.entries();i++)
      methNode->m_Params->addId(new skIdNode(paramNames[i],0));
  }
  return methNode;
}
//---------------------------------------------------
void skInterpreter::executeStringExternalParams(const skString& location,skExecutable * obj,skStringList& paramNames,const skString& code,skRValueArray& args,skRValue& r,skMethodDefNode** keepParseNode)
  //---------------------------------------------------
{      
  skMethodDefNode * parseNode=parseExternalParams(location,paramNames,code);
  if (parseNode)
    executeParseTree(location,obj,parseNode,args,r);
  // give the parse node back to the caller if they want it
  if (keepParseNode)
    *keepParseNode=parseNode;
  else
    delete parseNode;
}
//---------------------------------------------------
void skInterpreter::executeString(const skString& location,skExecutable * obj,const skString& code,skRValueArray& args,skRValue& r,skMethodDefNode** keepParseNode)
  //---------------------------------------------------
{      
  skMethodDefNode * parseNode=parseString(location,code);
  if (parseNode)
    executeParseTree(location,obj,parseNode,args,r);
  // give the parse node back to the caller if they want it
  if (keepParseNode)
    *keepParseNode=parseNode;
  else
    delete parseNode;
}
//---------------------------------------------------
skRValue P_Interpreter::evaluate(skExecutable * obj,skRValueTable& var,skExprNode * n)
  //---------------------------------------------------
{ 
  skRValue r;
  switch(n->getType()){
  case s_IdList:{
    skIdListNode * ids=(skIdListNode *)n;
    skIdNode * idNode=ids->getLastId();
    skString method_name=idNode->m_Id;
    if (ids->numIds()==1){
      if (idNode->m_Exprs==0)
	r=findValue(obj,var,method_name,ids->m_Attribute);
      else
	makeMethodCall(obj,skRValue(obj),var,method_name,idNode->m_Exprs,r);
    }else{
      skRValue robject;
      followIdList(obj,var,ids,robject);
      if (idNode->m_Exprs==0)
	extractValue(obj,robject,method_name,ids->m_Attribute,r);
      else
	makeMethodCall(obj,robject,var,method_name,idNode->m_Exprs,r);
    }
    break;
  }
  case s_String:
    r=skRValue(*((skLiteralNode *)n)->m_String);
    break;
  case s_Integer:
    r=skRValue(((skLiteralNode *)n)->m_Int);
    break;
  case s_Character:
    r=skRValue(((skLiteralNode *)n)->m_Char);
    break;
  case s_Float:
    r=skRValue(((skLiteralNode *)n)->m_Float);
    break;
  default:
    skOpNode * opNode=(skOpNode *)n;
    skRValue item1=evaluate(obj,var,opNode->m_Expr1);
    int item1Type=item1.type();
    switch(n->getType()){
    case s_Not:
      r=skRValue((bool)(!evaluate(obj,var,opNode->m_Expr1).boolValue()));
      break;
    case s_And:
      r=skRValue((bool)(evaluate(obj,var,opNode->m_Expr1).boolValue() && evaluate(obj,var,opNode->m_Expr2).boolValue()));
      break;
    case s_Or:
      r=skRValue((bool)(evaluate(obj,var,opNode->m_Expr1).boolValue() || evaluate(obj,var,opNode->m_Expr2).boolValue()));
      break;
    case s_Equals:
      r=skRValue(evaluate(obj,var,opNode->m_Expr1) == evaluate(obj,var,opNode->m_Expr2));
      break;
    case s_NotEquals:{
      bool equals=evaluate(obj,var,opNode->m_Expr1) == evaluate(obj,var,opNode->m_Expr2);
      if (equals)
	  r=false;
      else
	  r=true;
      break;
    }
    case s_Minus:
      if (item1Type==skRValue::T_Float)
	r=skRValue(-item1.floatValue());
      else
	r=skRValue((-item1.intValue()));
      break;
    case s_Concat:
      r=skRValue((evaluate(obj,var,opNode->m_Expr1).str() + evaluate(obj,var,opNode->m_Expr2).str()));
      break;
    default:{
	skRValue item2=evaluate(obj,var,opNode->m_Expr2);
	int item2Type=item2.type();
	if (item1Type==skRValue::T_Int && item2Type==skRValue::T_Int){
	  // we can use integer arithmetic if both objects are integer
	  int val1=item1.intValue();
	  int val2=item2.intValue();
	  switch(opNode->getType()){
	  case s_Plus:
	    r=skRValue(val1+val2);
	    break;
	  case s_More:
	    if (val1>val2)
	      r=skRValue(true);
	    else
	      r=skRValue(false);
	    break;
	  case s_Less:
	    if (val1<val2)
	      r=skRValue(true);
	    else
	      r=skRValue(false);
	    break;
	  case s_Subtract:
	    r=skRValue(val1-val2);
	    break;
	  case s_Divide:{
	    long top=val1;
	    long bottom=val2;
	    if (bottom)
	      r=skRValue((int)(top/bottom));
	    else
	      runtimeError("Divide by zero error");
	    break;
	  }
	  case s_Mult:
	    r=skRValue(val1*val2);
	    break;
	  case s_Mod:
	    r=skRValue(val1 % val2);
	    break;
	  }
	}else{
	  // in all other cases we using floating point
	  float val1=item1.floatValue();
	  float val2=item2.floatValue();
	  switch(opNode->getType()){
	  case s_Plus:
	    r=skRValue(val1+val2);
	    break;
	  case s_More:
	    if (val1>val2)
	      r=skRValue(true);
	    else
	      r=skRValue(false);
	    break;
	  case s_Less:
	    if (val1<val2)
	      r=skRValue(true);
	    else
	      r=skRValue(false);
	    break;
	  case s_Subtract:
	    r=skRValue(val1-val2);
	    break;
	  case s_Divide:{
	    double top=val1;
	    double bottom=val2;
	    if (bottom)
	      r=skRValue((float)(top/bottom));
	    else
	      runtimeError("Divide by zero error");
	    break;
	  }
	  case s_Mult:
	    r=skRValue(val1*val2);
	    break;
	  case s_Mod:
	    r=skRValue((int)((long)val1 % (long)val2));
	    break;
	  }
	}
      }
    }
  }
  return r;
}
//------------------------------------------
bool skInterpreter::setValue(const skString& s,const skString& attrib,const skRValue& v)
  //------------------------------------------
{
  bool bRet=false;
  if (s==s_tracing){
    pimp->m_Tracing=v.boolValue();
    bRet=true;
  }else
    bRet=skExecutable::setValue(s,attrib,v);
  return bRet;
}
// define DEBUGLEXER to get a verbose output of the workings of the lexer
//#define _DEBUGLEXER
#ifdef _DEBUGLEXER
#define DB(t) skTracer::trace("%d: %s\n",m_Pos,t);
#define DBN(t,n) skTracer::trace("%d: %s - %s\n",m_Pos,t,(const char *)n);
#define DBI(t,n) skTracer::trace("%d: %s - %d\n",m_Pos,t,n);
#define DBC(t,c) skTracer::trace("%d: %s - (%d) %c \n",m_Pos,t,(int)c,(char)c);
#else
#define DB(t) 
#define DBN(t,n) 
#define DBI(t,n) 
#define DBC(t,c) 
#endif
//------------------------------------------
inline int P_Interpreter::nextChar()
  //------------------------------------------
{
  int c=0;
  if (m_PutBack){
    c=m_PutBack;
    m_PutBack=0;
  }else{
    c=((const char *)m_InputBuffer)[m_Pos++];
  }
  return c;
}
//------------------------------------------
inline void P_Interpreter::putbackchar(int i)
  //------------------------------------------
{
  DBC("**putback",i);
  m_PutBack=i;
}
//------------------------------------------
inline bool P_Interpreter::eof()
  //------------------------------------------
{
  bool e=false;
  if (!m_PutBack)
    e=(m_Pos==m_InputBuffer.length()+1);
#ifdef _DEBUG        
  if (e){
    DB("Eof");
  }
#endif    	
  return e;  
}
//------------------------------------------
int P_Interpreter::lex()
  //------------------------------------------
  // Lexical Analyser
{
  int c=0;
  int yypos=0;
  m_LexBuffer[0]=0;
  while (!eof()){
    c=nextChar();
    if (c=='\n')
      m_LineNum++;
    // Whitespace----------------------------------------
    if (isspace(c)){
      continue;
    }
    // Identifier/Keyword--------------------------------
    if (isalpha(c) || c=='_' || c=='@'){
      do{
	if (yypos<MAXYYTEXT-2)
	  m_LexBuffer[yypos++]=c;
	else
	  break;
	c=nextChar();
      }while (!eof() && ( isalnum(c) || c=='_' ));
      if (!eof())
	putbackchar(c);
      m_LexBuffer[yypos]=0;
      int x=0;
      for (x=0;x<NUMKEYS;x++)
	if ((*keywords[x].m_Text)==m_LexBuffer){
	  c=keywords[x].m_Token;
	  yylval.string=keywords[x].m_Text;
	  DBN("keyword",*yylval.string);
	  break;
	}
      if (x==NUMKEYS){
	c=L_ID;
	yylval.string=new skString(m_LexBuffer);
	DBN("id",*yylval.string);
      }
      break;
    }
    // character--------------------------------------------
    if (c=='\''){
      c=nextChar();
      if (c=='\\'){
	c=nextChar();
	if (c=='n')
	  c='\n';
	else
	  if (c=='t')
	    c='\t';
      }
      nextChar();
      yylval.character=c;
      c=L_CHARACTER;
      DBN("character",yylval.character);
      break;
    }
    // string--------------------------------------------
    if (c=='"'){
      while(!eof()){
	c=nextChar();
	if (c=='\\'){
	  c=nextChar();
	  if (c=='n')
	    c='\n';
	  else
	    if (c=='t')
	      c='\t';
	}else
	  if (c=='"')
	    break;
	if (yypos<MAXYYTEXT-2)
	  m_LexBuffer[yypos++]=c;
	else
	  break;
      }
      m_LexBuffer[yypos]=0;
      c=L_STRING;
      yylval.string=new skString(m_LexBuffer);
      DBN("string",*yylval.string);
      break;    
    }
    // Integer or float----------------------------------
    if (isdigit(c)){
      enum {
	NUM_INTEGER,
	NUM_ZERO,
	NUM_HEX,
	NUM_FRACTION,
	NUM_EXPONENT_SIGN,
	NUM_EXPONENT,
	NUM_END
      } state;
      bool floating=false;
	  
      state = NUM_INTEGER;
      while (state != NUM_END) {
	switch (state) {
	case NUM_INTEGER:
	  if (isdigit(c)) 
	    m_LexBuffer[yypos++]=c;
	  else if (c == '.') {
	    m_LexBuffer[yypos++]=c;
	    state = NUM_FRACTION;
	    floating=true;
	  } else if (c == 'e' || c == 'E') {
	    floating=true;
	    m_LexBuffer[yypos++]=c;
	    state = NUM_EXPONENT_SIGN;
	  } else
	    state = NUM_END;
	  break;
	case NUM_FRACTION:
	  if (isdigit(c)) 
	    m_LexBuffer[yypos++]=c;
	  else if (c == 'e' || c == 'E') {
	    m_LexBuffer[yypos++]=c;
	    state = NUM_EXPONENT_SIGN;
	  } else
	    state = NUM_END;
	  break;
	case NUM_EXPONENT_SIGN:
	  if (c == '+' || c == '-' || isdigit(c)) {
	    m_LexBuffer[yypos++]=c;
	    state = NUM_EXPONENT;
	  }else
	    state = NUM_END;
	  break;
	case NUM_EXPONENT:
	  if (isdigit(c)) 
	    m_LexBuffer[yypos++]=c;
	  else
	    state = NUM_END;
	  break;
	}
	if (state != NUM_END)
	  c = nextChar();
      }
      putbackchar(c);
      m_LexBuffer[yypos++]=0;
      if (floating){
	yylval.floating=(float)(atof(m_LexBuffer));
	c=L_FLOAT;
      }else{
	yylval.integer=atoi(m_LexBuffer);
	c=L_INTEGER;
      }
      DBI("integer",(yylval.integer));
      break;    
    }
    // Comment-------------------------------------------
    if (c=='/'){
      int c1=nextChar();
      if (c1=='*'){
	do{
	  c1=nextChar();
	  if (c1=='*'){
	    c1=nextChar();
	    if (c1=='/')
	      break;
	  }
	}while (!eof());
	continue;
      }else
	if (c1=='/'){
	  do{
	    c1=nextChar();
	    if (c1=='\n'){
	      m_LineNum++;
	      break;
	    }
	  }while (!eof());
	  continue;
	}else
	  putbackchar(c1);
      break;
    }
    // Default case
    DBC("char",c);
    break;
  }
  return c;
}
//------------------------------------------
void P_Interpreter::runtimeError(const char * buffer,...)
  //------------------------------------------
{
  char msg[1024];
  va_list marker;
  va_start( marker, buffer);
  vsprintf(msg,buffer,marker);
  throw skRuntimeException(m_Location,msg);
}
//------------------------------------------
int yylex ( void )
  //------------------------------------------
{
  // this global function is called by the generated yyparse() function to produce the next token
  return P_Interpreter::g_Interpreter->pimp->lex();
}
//------------------------------------------
void yyerror(char * msg)
  //------------------------------------------
{ 
  // this global function is called by the generated yyparse() function if there is an error
  if (g_ErrList){
    g_ErrList->append(skCompileError(P_Interpreter::g_Interpreter->pimp->g_Location,P_Interpreter::g_Interpreter->pimp->m_LineNum,msg));
  }else
    P_Interpreter::g_Interpreter->pimp->runtimeError("%s line %d\n",msg,P_Interpreter::g_Interpreter->pimp->m_LineNum);
}
//------------------------------------------
skRValueTable::skRValueTable(unsigned short  size)
  //------------------------------------------
  : skTHashTable<skString,skRValue>(size)
{
}
//------------------------------------------
skRValueTable::skRValueTable()
  //------------------------------------------
{
}
//------------------------------------------
skRValueTable::~skRValueTable()
  //------------------------------------------
{
}



